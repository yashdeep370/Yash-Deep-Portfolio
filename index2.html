<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        .splash-canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }

        /* Overlay text to prove it's a background */
        #main {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: sans-serif;
            pointer-events: none; /* Allows clicks to pass through to the canvas */
            text-align: center;
            mix-blend-mode: exclusion;
        }

        h1 { font-size: 3rem; margin-bottom: 0.5rem; }
        p { font-size: 1.2rem; opacity: 0.8; }
    </style>
</head>
<body>

    <canvas class="splash-canvas"></canvas>
    
    <div id="main">
        <h1>Fluid Simulation</h1>
        <p>Click and Drag / Touch to interact</p>
    </div>

    <div class="theme-button" style="display: none;"></div>

<script>
"use strict";

const canvas = document.querySelector(".splash-canvas");
const homePageBody = document.querySelector("body");
const mainWrapper = document.querySelector("#main");
const modeChangeButton = document.querySelector(".theme-button");

resizeCanvas();

let config = {
    SIM_RESOLUTION: 128,
    DYE_RESOLUTION: 1024,
    CAPTURE_RESOLUTION: 512,
    DENSITY_DISSIPATION: 4,
    VELOCITY_DISSIPATION: 2.87,
    PRESSURE: 0.43,
    PRESSURE_ITERATIONS: 20,
    CURL: 0,
    SPLAT_RADIUS: 0.28,
    SPLAT_FORCE: 5000,
    SHADING: true,
    COLORFUL: true,
    COLOR_UPDATE_SPEED: 10,
    PAUSED: false,
    BACK_COLOR: { r: 0, g: 0, b: 0 },
    TRANSPARENT: false,
    BLOOM: true,
    BLOOM_ITERATIONS: 8,
    BLOOM_RESOLUTION: 256,
    BLOOM_INTENSITY: 0.1,
    BLOOM_THRESHOLD: 0.6,
    BLOOM_SOFT_KNEE: 0.7,
    SUNRAYS: true,
    SUNRAYS_RESOLUTION: 196,
    SUNRAYS_WEIGHT: 0.7
};

function pointerPrototype() {
    this.id = -1;
    this.texcoordX = 0;
    this.texcoordY = 0;
    this.prevTexcoordX = 0;
    this.prevTexcoordY = 0;
    this.deltaX = 0;
    this.deltaY = 0;
    this.down = false;
    this.moved = false;
    this.color = [30, 0, 300];
}

let pointers = [];
let splatStack = [];
pointers.push(new pointerPrototype());

const { gl, ext } = getWebGLContext(canvas);

function getWebGLContext(e) {
    const r = {
        alpha: true,
        depth: false,
        stencil: false,
        antialias: false,
        preserveDrawingBuffer: false
    };
    let t = e.getContext("webgl2", r);
    const n = !!t;
    let i, o;
    if (!n) {
        t = e.getContext("webgl", r) || e.getContext("experimental-webgl", r);
    }
    if (n) {
        t.getExtension("EXT_color_buffer_float");
        o = t.getExtension("OES_texture_float_linear");
    } else {
        i = t.getExtension("OES_texture_half_float");
        o = t.getExtension("OES_texture_half_float_linear");
    }
    t.clearColor(1, 1, 1, 1);
    const a = n ? t.HALF_FLOAT : i.HALF_FLOAT_OES;
    let l, u, c;
    if (n) {
        l = getSupportedFormat(t, t.RGBA16F, t.RGBA, a);
        u = getSupportedFormat(t, t.RG16F, t.RG, a);
        c = getSupportedFormat(t, t.R16F, t.RED, a);
    } else {
        l = getSupportedFormat(t, t.RGBA, t.RGBA, a);
        u = getSupportedFormat(t, t.RGBA, t.RGBA, a);
        c = getSupportedFormat(t, t.RGBA, t.RGBA, a);
    }
    return {
        gl: t,
        ext: {
            formatRGBA: l,
            formatRG: u,
            formatR: c,
            halfFloatTexType: a,
            supportLinearFiltering: o
        }
    };
}

function getSupportedFormat(e, r, t, n) {
    if (!supportRenderTextureFormat(e, r, t, n)) {
        switch (r) {
            case e.R16F:
                return getSupportedFormat(e, e.RG16F, e.RG, n);
            case e.RG16F:
                return getSupportedFormat(e, e.RGBA16F, e.RGBA, n);
            default:
                return null;
        }
    }
    return {
        internalFormat: r,
        format: t
    };
}

function supportRenderTextureFormat(e, r, t, n) {
    let i = e.createTexture();
    e.bindTexture(e.TEXTURE_2D, i);
    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST);
    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST);
    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE);
    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);
    e.texImage2D(e.TEXTURE_2D, 0, r, 4, 4, 0, t, n, null);
    let o = e.createFramebuffer();
    e.bindFramebuffer(e.FRAMEBUFFER, o);
    e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, i, 0);
    return e.checkFramebufferStatus(e.FRAMEBUFFER) == e.FRAMEBUFFER_COMPLETE;
}

function isMobile() {
    return /Mobi|Android/i.test(navigator.userAgent);
}

function captureScreenshot() {
    let e = getResolution(config.CAPTURE_RESOLUTION);
    let r = createFBO(e.width, e.height, ext.formatRGBA.internalFormat, ext.formatRGBA.format, ext.halfFloatTexType, gl.NEAREST);
    render(r);
    let t = framebufferToTexture(r);
    t = normalizeTexture(t, r.width, r.height);
    let n = textureToCanvas(t, r.width, r.height).toDataURL();
    downloadURI("fluid.png", n);
    URL.revokeObjectURL(n);
}

function framebufferToTexture(e) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, e.fbo);
    let r = e.width * e.height * 4;
    let t = new Float32Array(r);
    gl.readPixels(0, 0, e.width, e.height, gl.RGBA, gl.FLOAT, t);
    return t;
}

function normalizeTexture(e, r, t) {
    let n = new Uint8Array(e.length);
    let i = 0;
    for (let o = t - 1; o >= 0; o--) {
        for (let t = 0; t < r; t++) {
            let a = o * r * 4 + 4 * t;
            n[a + 0] = 255 * clamp01(e[i + 0]);
            n[a + 1] = 255 * clamp01(e[i + 1]);
            n[a + 2] = 255 * clamp01(e[i + 2]);
            n[a + 3] = 255 * clamp01(e[i + 3]);
            i += 4;
        }
    }
    return n;
}

function clamp01(e) {
    return Math.min(Math.max(e, 0), 1);
}

function textureToCanvas(e, r, t) {
    let n = document.createElement("canvas");
    let i = n.getContext("2d");
    n.width = r;
    n.height = t;
    let o = i.createImageData(r, t);
    o.data.set(e);
    i.putImageData(o, 0, 0);
    return n;
}

function downloadURI(e, r) {
    let t = document.createElement("a");
    t.download = e;
    t.href = r;
    document.body.appendChild(t);
    t.click();
    document.body.removeChild(t);
}

if (isMobile()) {
    config.DYE_RESOLUTION = 512;
}

if (!ext.supportLinearFiltering) {
    config.DYE_RESOLUTION = 512;
    config.SHADING = false;
    config.BLOOM = false;
    config.SUNRAYS = false;
}

class Material {
    constructor(e, r) {
        this.vertexShader = e;
        this.fragmentShaderSource = r;
        this.programs = [];
        this.activeProgram = null;
        this.uniforms = [];
    }
    setKeywords(e) {
        let r = 0;
        for (let t = 0; t < e.length; t++) r += hashCode(e[t]);
        let t = this.programs[r];
        if (t == null) {
            let n = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, e);
            t = createProgram(this.vertexShader, n);
            this.programs[r] = t;
        }
        if (t != this.activeProgram) {
            this.uniforms = getUniforms(t);
            this.activeProgram = t;
        }
    }
    bind() {
        gl.useProgram(this.activeProgram);
    }
}

class Program {
    constructor(e, r) {
        this.uniforms = {};
        this.program = createProgram(e, r);
        this.uniforms = getUniforms(this.program);
    }
    bind() {
        gl.useProgram(this.program);
    }
}

function createProgram(e, r) {
    let t = gl.createProgram();
    gl.attachShader(t, e);
    gl.attachShader(t, r);
    gl.linkProgram(t);
    if (!gl.getProgramParameter(t, gl.LINK_STATUS)) {
        console.trace(gl.getProgramInfoLog(t));
    }
    return t;
}

function getUniforms(e) {
    let r = [];
    let t = gl.getProgramParameter(e, gl.ACTIVE_UNIFORMS);
    for (let n = 0; n < t; n++) {
        let t = gl.getActiveUniform(e, n).name;
        r[t] = gl.getUniformLocation(e, t);
    }
    return r;
}

function compileShader(e, r, t) {
    r = addKeywords(r, t);
    const n = gl.createShader(e);
    gl.shaderSource(n, r);
    gl.compileShader(n);
    if (!gl.getShaderParameter(n, gl.COMPILE_STATUS)) {
        console.trace(gl.getShaderInfoLog(n));
    }
    return n;
}

function addKeywords(e, r) {
    if (r == null) return e;
    let t = "";
    r.forEach((e => {
        t += "#define " + e + "\n";
    }));
    return t + e;
}

const baseVertexShader = compileShader(gl.VERTEX_SHADER, `
    precision highp float;
    attribute vec2 aPosition;
    varying vec2 vUv;
    varying vec2 vL;
    varying vec2 vR;
    varying vec2 vT;
    varying vec2 vB;
    uniform vec2 texelSize;
    void main () {
        vUv = aPosition * 0.5 + 0.5;
        vL = vUv - vec2(texelSize.x, 0.0);
        vR = vUv + vec2(texelSize.x, 0.0);
        vT = vUv + vec2(0.0, texelSize.y);
        vB = vUv - vec2(0.0, texelSize.y);
        gl_Position = vec4(aPosition, 0.0, 1.0);
    }
`);

const blurVertexShader = compileShader(gl.VERTEX_SHADER, `
    precision highp float;
    attribute vec2 aPosition;
    varying vec2 vUv;
    varying vec2 vL;
    varying vec2 vR;
    uniform vec2 texelSize;
    void main () {
        vUv = aPosition * 0.5 + 0.5;
        float offset = 1.33333333;
        vL = vUv - texelSize * offset;
        vR = vUv + texelSize * offset;
        gl_Position = vec4(aPosition, 0.0, 1.0);
    }
`);

const blurShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;
    varying vec2 vUv;
    varying vec2 vL;
    varying vec2 vR;
    uniform sampler2D uTexture;
    void main () {
        vec4 sum = texture2D(uTexture, vUv) * 0.29411764;
        sum += texture2D(uTexture, vL) * 0.35294117;
        sum += texture2D(uTexture, vR) * 0.35294117;
        gl_FragColor = sum;
    }
`);

const copyShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;
    varying highp vec2 vUv;
    uniform sampler2D uTexture;
    void main () {
        gl_FragColor = texture2D(uTexture, vUv);
    }
`);

const clearShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;
    varying highp vec2 vUv;
    uniform sampler2D uTexture;
    uniform float value;
    void main () {
        gl_FragColor = value * texture2D(uTexture, vUv);
    }
`);

const colorShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    uniform vec4 color;
    void main () {
        gl_FragColor = color;
    }
`);

const checkerboardShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;
    varying vec2 vUv;
    uniform sampler2D uTexture;
    uniform float aspectRatio;
    #define SCALE 25.0
    void main () {
        vec2 uv = floor(vUv * SCALE * vec2(aspectRatio, 1.0));
        float v = mod(uv.x + uv.y, 2.0);
        v = v * 0.1 + 0.8;
        gl_FragColor = vec4(vec3(v), 1.0);
    }
`);

const displayShaderSource = `
    precision highp float;
    precision highp sampler2D;
    varying vec2 vUv;
    varying vec2 vL;
    varying vec2 vR;
    varying vec2 vT;
    varying vec2 vB;
    uniform sampler2D uTexture;
    uniform sampler2D uBloom;
    uniform sampler2D uSunrays;
    uniform sampler2D uDithering;
    uniform vec2 ditherScale;
    uniform vec2 texelSize;
    vec3 linearToGamma (vec3 color) {
        color = max(color, vec3(0));
        return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));
    }
    void main () {
        vec3 c = texture2D(uTexture, vUv).rgb;
    #ifdef SHADING
        vec3 lc = texture2D(uTexture, vL).rgb;
        vec3 rc = texture2D(uTexture, vR).rgb;
        vec3 tc = texture2D(uTexture, vT).rgb;
        vec3 bc = texture2D(uTexture, vB).rgb;
        float dx = length(rc) - length(lc);
        float dy = length(tc) - length(bc);
        vec3 n = normalize(vec3(dx, dy, length(texelSize)));
        vec3 l = vec3(0.0, 0.0, 1.0);
        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);
        c *= diffuse;
    #endif
    #ifdef BLOOM
        vec3 bloom = texture2D(uBloom, vUv).rgb;
    #endif
    #ifdef SUNRAYS
        float sunrays = texture2D(uSunrays, vUv).r;
        c *= sunrays;
    #ifdef BLOOM
        bloom *= sunrays;
    #endif
    #endif
    #ifdef BLOOM
        float noise = texture2D(uDithering, vUv * ditherScale).r;
        noise = noise * 2.0 - 1.0;
        bloom += noise / 255.0;
        bloom = linearToGamma(bloom);
        c += bloom;
    #endif
        float a = max(c.r, max(c.g, c.b));
        gl_FragColor = vec4(c, a);
    }
`;

const bloomPrefilterShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;
    varying vec2 vUv;
    uniform sampler2D uTexture;
    uniform vec3 curve;
    uniform float threshold;
    void main () {
        vec3 c = texture2D(uTexture, vUv).rgb;
        float br = max(c.r, max(c.g, c.b));
        float rq = clamp(br - curve.x, 0.0, curve.y);
        rq = curve.z * rq * rq;
        c *= max(rq, br - threshold) / max(br, 0.0001);
        gl_FragColor = vec4(c, 0.0);
    }
`);

const bloomBlurShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;
    varying vec2 vL;
    varying vec2 vR;
    varying vec2 vT;
    varying vec2 vB;
    uniform sampler2D uTexture;
    void main () {
        vec4 sum = vec4(0.0);
        sum += texture2D(uTexture, vL);
        sum += texture2D(uTexture, vR);
        sum += texture2D(uTexture, vT);
        sum += texture2D(uTexture, vB);
        sum *= 0.25;
        gl_FragColor = sum;
    }
`);

const bloomFinalShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;
    varying vec2 vL;
    varying vec2 vR;
    varying vec2 vT;
    varying vec2 vB;
    uniform sampler2D uTexture;
    uniform float intensity;
    void main () {
        vec4 sum = vec4(0.0);
        sum += texture2D(uTexture, vL);
        sum += texture2D(uTexture, vR);
        sum += texture2D(uTexture, vT);
        sum += texture2D(uTexture, vB);
        sum *= 0.25;
        gl_FragColor = sum * intensity;
    }
`);

const sunraysMaskShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;
    varying vec2 vUv;
    uniform sampler2D uTexture;
    void main () {
        vec4 c = texture2D(uTexture, vUv);
        float br = max(c.r, max(c.g, c.b));
        c.a = 1.0 - min(max(br * 20.0, 0.0), 0.8);
        gl_FragColor = c;
    }
`);

const sunraysShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;
    varying vec2 vUv;
    uniform sampler2D uTexture;
    uniform float weight;
    #define ITERATIONS 16
    void main () {
        float Density = 0.3;
        float Decay = 0.95;
        float Exposure = 0.7;
        vec2 coord = vUv;
        vec2 dir = vUv - 0.5;
        dir *= 1.0 / float(ITERATIONS) * Density;
        float illuminationDecay = 1.0;
        float color = texture2D(uTexture, vUv).a;
        for (int i = 0; i < ITERATIONS; i++) {
            coord -= dir;
            float col = texture2D(uTexture, coord).a;
            color += col * illuminationDecay * weight;
            illuminationDecay *= Decay;
        }
        gl_FragColor = vec4(color * Exposure, 0.0, 0.0, 1.0);
    }
`);

const splatShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;
    varying vec2 vUv;
    uniform sampler2D uTarget;
    uniform float aspectRatio;
    uniform vec3 color;
    uniform vec2 point;
    uniform float radius;
    void main () {
        vec2 p = vUv - point.xy;
        p.x *= aspectRatio;
        vec3 splat = exp(-dot(p, p) / radius) * color;
        vec3 base = texture2D(uTarget, vUv).xyz;
        gl_FragColor = vec4(base + splat, 1.0);
    }
`);

const advectionShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;
    varying vec2 vUv;
    uniform sampler2D uVelocity;
    uniform sampler2D uSource;
    uniform vec2 texelSize;
    uniform vec2 dyeTexelSize;
    uniform float dt;
    uniform float dissipation;
    vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {
        vec2 st = uv / tsize - 0.5;
        vec2 iuv = floor(st);
        vec2 fuv = fract(st);
        vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);
        vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);
        vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);
        vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);
        return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);
    }
    void main () {
    #ifdef MANUAL_FILTERING
        vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;
        vec4 result = bilerp(uSource, coord, dyeTexelSize);
    #else
        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
        vec4 result = texture2D(uSource, coord);
    #endif
        float decay = 1.0 + dissipation * dt;
        gl_FragColor = result / decay;
    }
`, ext.supportLinearFiltering ? null : ["MANUAL_FILTERING"]);

const divergenceShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;
    varying highp vec2 vUv;
    varying highp vec2 vL;
    varying highp vec2 vR;
    varying highp vec2 vT;
    varying highp vec2 vB;
    uniform sampler2D uVelocity;
    void main () {
        float L = texture2D(uVelocity, vL).x;
        float R = texture2D(uVelocity, vR).x;
        float T = texture2D(uVelocity, vT).y;
        float B = texture2D(uVelocity, vB).y;
        vec2 C = texture2D(uVelocity, vUv).xy;
        if (vL.x < 0.0) { L = -C.x; }
        if (vR.x > 1.0) { R = -C.x; }
        if (vT.y > 1.0) { T = -C.y; }
        if (vB.y < 0.0) { B = -C.y; }
        float div = 0.5 * (R - L + T - B);
        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
    }
`);

const curlShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;
    varying highp vec2 vUv;
    varying highp vec2 vL;
    varying highp vec2 vR;
    varying highp vec2 vT;
    varying highp vec2 vB;
    uniform sampler2D uVelocity;
    void main () {
        float L = texture2D(uVelocity, vL).y;
        float R = texture2D(uVelocity, vR).y;
        float T = texture2D(uVelocity, vT).x;
        float B = texture2D(uVelocity, vB).x;
        float vorticity = R - L - T + B;
        gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
    }
`);

const vorticityShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;
    varying vec2 vUv;
    varying vec2 vL;
    varying vec2 vR;
    varying vec2 vT;
    varying vec2 vB;
    uniform sampler2D uVelocity;
    uniform sampler2D uCurl;
    uniform float curl;
    uniform float dt;
    void main () {
        float L = texture2D(uCurl, vL).x;
        float R = texture2D(uCurl, vR).x;
        float T = texture2D(uCurl, vT).x;
        float B = texture2D(uCurl, vB).x;
        float C = texture2D(uCurl, vUv).x;
        vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
        force /= length(force) + 0.0001;
        force *= curl * C;
        force.y *= -1.0;
        vec2 velocity = texture2D(uVelocity, vUv).xy;
        velocity += force * dt;
        velocity = min(max(velocity, -1000.0), 1000.0);
        gl_FragColor = vec4(velocity, 0.0, 1.0);
    }
`);

const pressureShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;
    varying highp vec2 vUv;
    varying highp vec2 vL;
    varying highp vec2 vR;
    varying highp vec2 vT;
    varying highp vec2 vB;
    uniform sampler2D uPressure;
    uniform sampler2D uDivergence;
    void main () {
        float L = texture2D(uPressure, vL).x;
        float R = texture2D(uPressure, vR).x;
        float T = texture2D(uPressure, vT).x;
        float B = texture2D(uPressure, vB).x;
        float C = texture2D(uPressure, vUv).x;
        float divergence = texture2D(uDivergence, vUv).x;
        float pressure = (L + R + B + T - divergence) * 0.25;
        gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
    }
`);

const gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;
    varying highp vec2 vUv;
    varying highp vec2 vL;
    varying highp vec2 vR;
    varying highp vec2 vT;
    varying highp vec2 vB;
    uniform sampler2D uPressure;
    uniform sampler2D uVelocity;
    void main () {
        float L = texture2D(uPressure, vL).x;
        float R = texture2D(uPressure, vR).x;
        float T = texture2D(uPressure, vT).x;
        float B = texture2D(uPressure, vB).x;
        vec2 velocity = texture2D(uVelocity, vUv).xy;
        velocity.xy -= vec2(R - L, T - B);
        gl_FragColor = vec4(velocity, 0.0, 1.0);
    }
`);

const blit = (() => {
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);

    return (e, r = false) => {
        if (e == null) {
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        } else {
            gl.viewport(0, 0, e.width, e.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, e.fbo);
        }
        if (r) {
            gl.clearColor(1, 1, 1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    };
})();

function CHECK_FRAMEBUFFER_STATUS() {
    let e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (e != gl.FRAMEBUFFER_COMPLETE) {
        console.trace("Framebuffer error: " + e);
    }
}

let dye, velocity, divergence, curl, pressure, bloom, sunrays, sunraysTemp;
let bloomFramebuffers = [];
let ditheringTexture = createTextureAsync("LDR_LLL1_0.png");

const blurProgram = new Program(blurVertexShader, blurShader);
const copyProgram = new Program(baseVertexShader, copyShader);
const clearProgram = new Program(baseVertexShader, clearShader);
const colorProgram = new Program(baseVertexShader, colorShader);
const checkerboardProgram = new Program(baseVertexShader, checkerboardShader);
const bloomPrefilterProgram = new Program(baseVertexShader, bloomPrefilterShader);
const bloomBlurProgram = new Program(baseVertexShader, bloomBlurShader);
const bloomFinalProgram = new Program(baseVertexShader, bloomFinalShader);
const sunraysMaskProgram = new Program(baseVertexShader, sunraysMaskShader);
const sunraysProgram = new Program(baseVertexShader, sunraysShader);
const splatProgram = new Program(baseVertexShader, splatShader);
const advectionProgram = new Program(baseVertexShader, advectionShader);
const divergenceProgram = new Program(baseVertexShader, divergenceShader);
const curlProgram = new Program(baseVertexShader, curlShader);
const vorticityProgram = new Program(baseVertexShader, vorticityShader);
const pressureProgram = new Program(baseVertexShader, pressureShader);
const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);
const displayMaterial = new Material(baseVertexShader, displayShaderSource);

function initFramebuffers() {
    let e = getResolution(config.SIM_RESOLUTION);
    let r = getResolution(config.DYE_RESOLUTION);
    const t = ext.halfFloatTexType;
    const n = ext.formatRGBA;
    const i = ext.formatRG;
    const o = ext.formatR;
    const a = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;

    gl.disable(gl.BLEND);

    dye = dye == null ? createDoubleFBO(r.width, r.height, n.internalFormat, n.format, t, a) : resizeDoubleFBO(dye, r.width, r.height, n.internalFormat, n.format, t, a);
    velocity = velocity == null ? createDoubleFBO(e.width, e.height, i.internalFormat, i.format, t, a) : resizeDoubleFBO(velocity, e.width, e.height, i.internalFormat, i.format, t, a);
    divergence = createFBO(e.width, e.height, o.internalFormat, o.format, t, gl.NEAREST);
    curl = createFBO(e.width, e.height, o.internalFormat, o.format, t, gl.NEAREST);
    pressure = createDoubleFBO(e.width, e.height, o.internalFormat, o.format, t, gl.NEAREST);

    initBloomFramebuffers();
    initSunraysFramebuffers();
}

function initBloomFramebuffers() {
    let e = getResolution(config.BLOOM_RESOLUTION);
    const r = ext.halfFloatTexType;
    const t = ext.formatRGBA;
    const n = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;
    bloom = createFBO(e.width, e.height, t.internalFormat, t.format, r, n);
    bloomFramebuffers.length = 0;
    for (let i = 0; i < config.BLOOM_ITERATIONS; i++) {
        let o = e.width >> i + 1;
        let a = e.height >> i + 1;
        if (o < 2 || a < 2) break;
        let l = createFBO(o, a, t.internalFormat, t.format, r, n);
        bloomFramebuffers.push(l);
    }
}

function initSunraysFramebuffers() {
    let e = getResolution(config.SUNRAYS_RESOLUTION);
    const r = ext.halfFloatTexType;
    const t = ext.formatR;
    const n = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;
    sunrays = createFBO(e.width, e.height, t.internalFormat, t.format, r, n);
    sunraysTemp = createFBO(e.width, e.height, t.internalFormat, t.format, r, n);
}

function createFBO(e, r, t, n, i, o) {
    gl.activeTexture(gl.TEXTURE0);
    let a = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, a);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, o);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, o);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, t, e, r, 0, n, i, null);
    let l = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, l);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, a, 0);
    gl.viewport(0, 0, e, r);
    gl.clear(gl.COLOR_BUFFER_BIT);
    return {
        texture: a,
        fbo: l,
        width: e,
        height: r,
        texelSizeX: 1 / e,
        texelSizeY: 1 / r,
        attach: e => {
            gl.activeTexture(gl.TEXTURE0 + e);
            gl.bindTexture(gl.TEXTURE_2D, a);
            return e;
        }
    };
}

function createDoubleFBO(e, r, t, n, i, o) {
    let a = createFBO(e, r, t, n, i, o);
    let l = createFBO(e, r, t, n, i, o);
    return {
        width: e,
        height: r,
        texelSizeX: a.texelSizeX,
        texelSizeY: a.texelSizeY,
        get read() {
            return a;
        },
        set read(e) {
            a = e;
        },
        get write() {
            return l;
        },
        set write(e) {
            l = e;
        },
        swap() {
            let e = a;
            a = l;
            l = e;
        }
    };
}

function resizeFBO(e, r, t, n, i, o, a) {
    let l = createFBO(r, t, n, i, o, a);
    copyProgram.bind();
    gl.uniform1i(copyProgram.uniforms.uTexture, e.attach(0));
    blit(l);
    return l;
}

function resizeDoubleFBO(e, r, t, n, i, o, a) {
    if (e.width == r && e.height == t) return e;
    e.read = resizeFBO(e.read, r, t, n, i, o, a);
    e.write = createFBO(r, t, n, i, o, a);
    e.width = r;
    e.height = t;
    e.texelSizeX = 1 / r;
    e.texelSizeY = 1 / t;
    return e;
}

function createTextureAsync(e) {
    let r = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, r);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255]));
    let t = {
        texture: r,
        width: 1,
        height: 1,
        attach: e => {
            gl.activeTexture(gl.TEXTURE0 + e);
            gl.bindTexture(gl.TEXTURE_2D, r);
            return e;
        }
    };
    let n = new Image();
    n.onload = () => {
        t.width = n.width;
        t.height = n.height;
        gl.bindTexture(gl.TEXTURE_2D, r);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, n);
    };
    n.src = e;
    return t;
}

function updateKeywords() {
    let e = [];
    if (config.SHADING) e.push("SHADING");
    if (config.BLOOM) e.push("BLOOM");
    if (config.SUNRAYS) e.push("SUNRAYS");
    displayMaterial.setKeywords(e);
}

updateKeywords();
initFramebuffers();
multipleSplats(parseInt(20 * Math.random()) + 5);

let lastUpdateTime = Date.now();
let colorUpdateTimer = 0;

function update() {
    const e = calcDeltaTime();
    if (resizeCanvas()) initFramebuffers();
    updateColors(e);
    applyInputs();
    if (!config.PAUSED) step(e);
    render(null);
    requestAnimationFrame(update);
}

function calcDeltaTime() {
    let e = Date.now();
    let r = (e - lastUpdateTime) / 1000;
    r = Math.min(r, 0.016666);
    lastUpdateTime = e;
    return r;
}

function resizeCanvas() {
    let e = scaleByPixelRatio(canvas.clientWidth);
    let r = scaleByPixelRatio(canvas.clientHeight);
    if (canvas.width != e || canvas.height != r) {
        canvas.width = e;
        canvas.height = r;
        return true;
    }
    return false;
}

function updateColors(e) {
    if (!config.COLORFUL) return;
    colorUpdateTimer += e * config.COLOR_UPDATE_SPEED;
    if (colorUpdateTimer >= 1) {
        colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);
        pointers.forEach((e => {
            e.color = generateColor();
        }));
    }
}

function applyInputs() {
    if (splatStack.length > 0) multipleSplats(splatStack.pop());
    pointers.forEach((e => {
        if (e.moved) {
            e.moved = false;
            splatPointer(e);
        }
    }));
}

function step(e) {
    gl.disable(gl.BLEND);
    
    // Curl
    curlProgram.bind();
    gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
    gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));
    blit(curl);

    // Vorticity
    vorticityProgram.bind();
    gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
    gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));
    gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));
    gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);
    gl.uniform1f(vorticityProgram.uniforms.dt, e);
    blit(velocity.write);
    velocity.swap();

    // Divergence
    divergenceProgram.bind();
    gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
    gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));
    blit(divergence);

    // Clear
    clearProgram.bind();
    gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));
    gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);
    blit(pressure.write);
    pressure.swap();

    // Pressure
    pressureProgram.bind();
    gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
    gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));
    for (let e = 0; e < config.PRESSURE_ITERATIONS; e++) {
        gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));
        blit(pressure.write);
        pressure.swap();
    }

    // Gradient Subtract
    gradienSubtractProgram.bind();
    gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
    gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));
    gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));
    blit(velocity.write);
    velocity.swap();

    // Advection Velocity
    advectionProgram.bind();
    gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
    if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);
    let r = velocity.read.attach(0);
    gl.uniform1i(advectionProgram.uniforms.uVelocity, r);
    gl.uniform1i(advectionProgram.uniforms.uSource, r);
    gl.uniform1f(advectionProgram.uniforms.dt, e);
    gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);
    blit(velocity.write);
    velocity.swap();

    // Advection Dye
    if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);
    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));
    gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));
    gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);
    blit(dye.write);
    dye.swap();
}

function render(e) {
    if (config.BLOOM) applyBloom(dye.read, bloom);
    if (config.SUNRAYS) {
        applySunrays(dye.read, dye.write, sunrays);
        blur(sunrays, sunraysTemp, 1);
    }
    if (e != null && config.TRANSPARENT) {
        gl.disable(gl.BLEND);
    } else {
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
    }
    if (!config.TRANSPARENT) drawColor(e, normalizeColor(config.BACK_COLOR));
    if (e == null && config.TRANSPARENT) drawCheckerboard(e);
    drawDisplay(e);
}

function drawColor(e, r) {
    colorProgram.bind();
    gl.uniform4f(colorProgram.uniforms.color, r.r, r.g, r.b, 1);
    blit(e);
}

function drawCheckerboard(e) {
    checkerboardProgram.bind();
    gl.uniform1f(checkerboardProgram.uniforms.aspectRatio, canvas.width / canvas.height);
    blit(e);
}

function drawDisplay(e) {
    let r = e == null ? gl.drawingBufferWidth : e.width;
    let t = e == null ? gl.drawingBufferHeight : e.height;
    displayMaterial.bind();
    if (config.SHADING) gl.uniform2f(displayMaterial.uniforms.texelSize, 1 / r, 1 / t);
    gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));
    if (config.BLOOM) {
        gl.uniform1i(displayMaterial.uniforms.uBloom, bloom.attach(1));
        gl.uniform1i(displayMaterial.uniforms.uDithering, ditheringTexture.attach(2));
        let e = getTextureScale(ditheringTexture, r, t);
        gl.uniform2f(displayMaterial.uniforms.ditherScale, e.x, e.y);
    }
    if (config.SUNRAYS) gl.uniform1i(displayMaterial.uniforms.uSunrays, sunrays.attach(3));
    blit(e);
}

function applyBloom(e, r) {
    if (bloomFramebuffers.length < 2) return;
    let t = r;
    gl.disable(gl.BLEND);
    bloomPrefilterProgram.bind();
    let n = config.BLOOM_THRESHOLD * config.BLOOM_SOFT_KNEE + 0.0001;
    let i = config.BLOOM_THRESHOLD - n;
    let o = 2 * n;
    let a = 0.25 / n;
    gl.uniform3f(bloomPrefilterProgram.uniforms.curve, i, o, a);
    gl.uniform1f(bloomPrefilterProgram.uniforms.threshold, config.BLOOM_THRESHOLD);
    gl.uniform1i(bloomPrefilterProgram.uniforms.uTexture, e.attach(0));
    blit(t);
    bloomBlurProgram.bind();
    for (let e = 0; e < bloomFramebuffers.length; e++) {
        let r = bloomFramebuffers[e];
        gl.uniform2f(bloomBlurProgram.uniforms.texelSize, t.texelSizeX, t.texelSizeY);
        gl.uniform1i(bloomBlurProgram.uniforms.uTexture, t.attach(0));
        blit(r);
        t = r;
    }
    gl.blendFunc(gl.ONE, gl.ONE);
    gl.enable(gl.BLEND);
    for (let e = bloomFramebuffers.length - 2; e >= 0; e--) {
        let r = bloomFramebuffers[e];
        gl.uniform2f(bloomBlurProgram.uniforms.texelSize, t.texelSizeX, t.texelSizeY);
        gl.uniform1i(bloomBlurProgram.uniforms.uTexture, t.attach(0));
        gl.viewport(0, 0, r.width, r.height);
        blit(r);
        t = r;
    }
    gl.disable(gl.BLEND);
    bloomFinalProgram.bind();
    gl.uniform2f(bloomFinalProgram.uniforms.texelSize, t.texelSizeX, t.texelSizeY);
    gl.uniform1i(bloomFinalProgram.uniforms.uTexture, t.attach(0));
    gl.uniform1f(bloomFinalProgram.uniforms.intensity, config.BLOOM_INTENSITY);
    blit(r);
}

function applySunrays(e, r, t) {
    gl.disable(gl.BLEND);
    sunraysMaskProgram.bind();
    gl.uniform1i(sunraysMaskProgram.uniforms.uTexture, e.attach(0));
    blit(r);
    sunraysProgram.bind();
    gl.uniform1f(sunraysProgram.uniforms.weight, config.SUNRAYS_WEIGHT);
    gl.uniform1i(sunraysProgram.uniforms.uTexture, r.attach(0));
    blit(t);
}

function blur(e, r, t) {
    blurProgram.bind();
    for (let n = 0; n < t; n++) {
        gl.uniform2f(blurProgram.uniforms.texelSize, e.texelSizeX, 0);
        gl.uniform1i(blurProgram.uniforms.uTexture, e.attach(0));
        blit(r);
        gl.uniform2f(blurProgram.uniforms.texelSize, 0, e.texelSizeY);
        gl.uniform1i(blurProgram.uniforms.uTexture, r.attach(0));
        blit(e);
    }
}

function splatPointer(e) {
    let r = e.deltaX * config.SPLAT_FORCE;
    let t = e.deltaY * config.SPLAT_FORCE;
    splat(e.texcoordX, e.texcoordY, r, t, e.color);
}

function multipleSplats(e) {
    for (let r = 0; r < e; r++) {
        const e = generateColor();
        e.r *= 10;
        e.g *= 10;
        e.b *= 10;
        splat(Math.random(), Math.random(), 1000 * (Math.random() - 0.5), 1000 * (Math.random() - 0.5), e);
    }
}

function splat(e, r, t, n, i) {
    splatProgram.bind();
    gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));
    gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);
    if (window.innerWidth <= 768) {
        gl.uniform2f(splatProgram.uniforms.point, e, Math.abs(r + window.scrollY / window.innerHeight) % 1);
    } else {
        gl.uniform2f(splatProgram.uniforms.point, e, r);
    }
    gl.uniform3f(splatProgram.uniforms.color, t, n, 0);
    gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100));
    blit(velocity.write);
    velocity.swap();
    gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));
    gl.uniform3f(splatProgram.uniforms.color, i.r, i.g, i.b);
    blit(dye.write);
    dye.swap();
}

function correctRadius(e) {
    let r = canvas.width / canvas.height;
    if (r > 1) e *= r;
    return e;
}

function updatePointerDownData(e, r, t, n) {
    e.id = r;
    e.down = true;
    e.moved = false;
    e.texcoordX = t / canvas.width;
    e.texcoordY = 1 - n / canvas.height;
    e.prevTexcoordX = e.texcoordX;
    e.prevTexcoordY = e.texcoordY;
    e.deltaX = 0;
    e.deltaY = 0;
    e.color = generateColor();
}

function updatePointerMoveData(e, r, t) {
    e.prevTexcoordX = e.texcoordX;
    e.prevTexcoordY = e.texcoordY;
    e.texcoordX = r / canvas.width;
    e.texcoordY = 1 - t / canvas.height;
    e.deltaX = correctDeltaX(e.texcoordX - e.prevTexcoordX);
    e.deltaY = correctDeltaY(e.texcoordY - e.prevTexcoordY);
    e.moved = Math.abs(e.deltaX) > 0 || Math.abs(e.deltaY) > 0;
}

function updatePointerUpData(e) {
    e.down = false;
}

function correctDeltaX(e) {
    let r = canvas.width / canvas.height;
    if (r < 1) e *= r;
    return e;
}

function correctDeltaY(e) {
    let r = canvas.width / canvas.height;
    if (r > 1) e /= r;
    return e;
}

function generateColor() {
    let e = HSVtoRGB(Math.random(), 1.0, 1.0);
    e.r *= 0.15;
    e.g *= 0.15;
    e.b *= 0.15;
    return e;
}

function HSVtoRGB(e, r, t) {
    let n, i, o, a, l, u, c, g;
    a = Math.floor(6 * e);
    l = 6 * e - a;
    u = t * (1 - r);
    c = t * (1 - l * r);
    g = t * (1 - (1 - l) * r);
    switch (a % 6) {
        case 0:
            n = t;
            i = g;
            o = u;
            break;
        case 1:
            n = c;
            i = t;
            o = u;
            break;
        case 2:
            n = u;
            i = t;
            o = g;
            break;
        case 3:
            n = u;
            i = c;
            o = t;
            break;
        case 4:
            n = g;
            i = u;
            o = t;
            break;
        case 5:
            n = t;
            i = u;
            o = c;
            break;
    }
    return {
        r: n,
        g: i,
        b: o
    };
}

function normalizeColor(e) {
    return {
        r: e.r / 255,
        g: e.g / 255,
        b: e.b / 255
    };
}

function wrap(e, r, t) {
    let n = t - r;
    if (n == 0) return r;
    return (e - r) % n + r;
}

function getResolution(e) {
    let r = gl.drawingBufferWidth / gl.drawingBufferHeight;
    if (r < 1) r = 1 / r;
    let t = Math.round(e);
    let n = Math.round(e * r);
    return gl.drawingBufferWidth > gl.drawingBufferHeight ? {
        width: n,
        height: t
    } : {
        width: t,
        height: n
    };
}

function getTextureScale(e, r, t) {
    return {
        x: r / e.width,
        y: t / e.height
    };
}

function scaleByPixelRatio(e) {
    let r = window.devicePixelRatio || 1;
    return Math.floor(e * r);
}

function hashCode(e) {
    if (e.length == 0) return 0;
    let r = 0;
    for (let t = 0; t < e.length; t++) {
        r = (r << 5) - r + e.charCodeAt(t);
        r |= 0;
    }
    return r;
}

update();

homePageBody.addEventListener("mouseover", (e => {
    let r = scaleByPixelRatio(e.clientX);
    let t = scaleByPixelRatio(e.clientY);
    let n = pointers.find((e => -1 == e.id));
    if (n == null) n = new pointerPrototype();
    updatePointerDownData(n, -1, r, t);
}));

homePageBody.addEventListener("mousemove", (e => {
    let r = pointers[0];
    if (r.down) updatePointerMoveData(r, scaleByPixelRatio(e.clientX), scaleByPixelRatio(e.clientY));
}));

window.addEventListener("mouseup", (() => {
    updatePointerUpData(pointers[0]);
}));

homePageBody.addEventListener("touchstart", (e => {
    e.preventDefault();
    const r = e.targetTouches;
    while (r.length >= pointers.length) pointers.push(new pointerPrototype());
    for (let e = 0; e < r.length; e++) {
        let t = scaleByPixelRatio(r[e].pageX);
        let n = scaleByPixelRatio(r[e].pageY);
        updatePointerDownData(pointers[e + 1], r[e].identifier, t, n);
    }
}));

homePageBody.addEventListener("touchmove", (e => {
    e.preventDefault();
    const r = e.targetTouches;
    for (let e = 0; e < r.length; e++) {
        let t = pointers[e + 1];
        if (t.down) updatePointerMoveData(t, scaleByPixelRatio(r[e].pageX), scaleByPixelRatio(r[e].pageY));
    }
}), false);

window.addEventListener("touchend", (e => {
    const r = e.changedTouches;
    for (let e = 0; e < r.length; e++) {
        let t = pointers.find((t => t.id == r[e].identifier));
        if (t != null) updatePointerUpData(t);
    }
}));
</script>
</body>
</html>